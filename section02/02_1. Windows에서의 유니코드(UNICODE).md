# **제2장\_1 : Windows에서의 유니코드(UNICODE)**

### 📌 **MBCS 기반 환경에서 한글을 사용할 때 발생하는 문제점은 무엇인가?**

MBCS 기반 환경에서 한글과 영문이 섞인 문자열의 길이를 계산할 때, 한글을 2바이트 문자로 인식 후 실제 문자열 길이와 다르게 계산되는 문제가 발생할 수 있다.

> 💡 이러한 문제를 해결하기 위한 유니코드 기반 프로그래밍 방법은?

- 문자를 표현할 때 char 대신 wchar_t 자료형 사용
- 문자열 선언 시 문자열 앞에 L 키워드 붙이기
- 문자열 조작 함수 사용 시 와이드 바이트 캐릭터 셋 기반 함수 사용
- main 함수 대신 wmain 함수 사용 및 전달 인자 타입을 wchar_t로 변경

---

## 목차

1. 📚 유니코드의 필요성과 특성
2. 🔍 MBCS 기반 한글 표현 문제점
3. 🖥️ 유니코드 기반 프로그래밍의 기초
4. 🅰️ 유니코드 기반 문자열 처리의 중요성
5. 🖨️ 유니코드 기반 문자열 처리

# 1. 📚 유니코드의 필요성과 특성

- 아스키 코드는 싱글 바이트 캐릭터 셋(SBCS)으로, 많은 코드 셋 중 하나이고, 주로 영어 문자 표현에 사용된다.
- 멀티 바이트 캐릭터 셋(MBCS)은 문자를 표현하는데 여러 바이트를 사용하여 영어와 한글을 효율적으로 처리할 수 있다.
- 유니코드는 와이드 바이트 캐릭터 셋(WBCS)으로, 모든 문자를 2바이트로 표현하여 안정성을 제공한다.

# 2. 🔍 MBCS 기반 한글 표현 문제점

- SBCS(Single Byte Character Set)

  - 문자를 표현하는 데 1바이트 사용
  - 아스키 코드

- MBCS(Multi Byte Character Set)

  - 한글은 2바이트, 영문은 1바이트 사용

- WBCS(Wide Byte Character Set)

  - 문자를 표현하는 데 2바이트 사용
  - 유니코드

- MBCS 기반에서 영어와 한글이 혼합된 문자열에서 메모리 크기와 문자열 길이 계산에서 문제를 겪는 경우가 발생한다.
- 문자열의 배열 길이는 8이지만, 실제 문자열 길이는 7로, 이는 한글이 각 2바이트로 인식되어 오류가 발생함을 보여준다.
- 예제에서 문자열의 길이를 5로 잘못 판단하여 출력 결과가 두 글자 "한글"로 제한되고, 이는 프로그래머가 흔히 실수할 여지가 있다.
- 프로그래밍에서 한글을 다루는 경우, 유니코드를 사용하는 것이 안정성을 높이고 실수를 줄일 수 있는 접근 방법이다.

# 3. 🖥️ 유니코드 기반 프로그래밍의 기초

- WBCS를 위한 두가지

  - 첫째: char를 대신하는 wchar_t
  - 둘째: "ABC"를 대신하는 L"ABC"

- WBCS 기반 문자열 선언 예

  - wchar_t str[]=L"ABC";

- 유니코드 기반으로 프로그래밍 하기 위해 **와이드 바이트 캐릭터**인 W이드 캐릭터 자료형을 사용해야 한다. 기본 자료형으로, 일반적인 문자 타입과 큰 차이점이 없다
- 문자열을 선언할 때, 아스키 코드 기반의 표현을 피하기 위해, 앞에 L이라는 키워드를 붙여서 유니코드 기반으로 선언해야 한다.
- 기존의 아스키 코드 기반 문자열에서 유니코드 문자열로의 변경이 필요하다.
- 유니코드와 아스키 문자열의 메모리 크기 확인은 사이즈 오브 연산자를 통해 가능, 함수 정의에서의 타입 불일치로 에러가 발생할 수 있다.
- 유니코드로 선언된 문자열 포인터가 아스키 타입으로 전달될 경우, 컴파일 에러가 발생하여 함수의 선언을 확인해야 한다.

# 4. 🅰️ 유니코드 기반 문자열 처리의 중요성

## 표 2-1] 문자열 조작 함수

| SBCS 함수 | WBCS 기반의 문자열 조작 함수                                         |
| --------- | -------------------------------------------------------------------- |
| strlen    | size_t wcslen (const wchar_t\* string);                              |
| strcpy    | wchar_t\* wcscpy (wchar_t\* dest, const wchar_t\* src);              |
| strncpy   | wchar_t\* wcsncpy (wchar_t\* dest, const wchar_t\* src, size_t cnt); |
| strcat    | wchar_t\* wcscat (wchar_t\* dest, const wchar_t\* src);              |
| strncat   | wchar_t\* wcsncat (wchar_t\* dest, const wchar_t\* src, size_t cnt); |
| strcmp    | int wcscmp (const wchar_t\* s1, const wchar_t\* s2);                 |
| strncmp   | int wcsncmp (const wchar_t\* s1, const wchar_t\* s2, size_t cnt);    |

- **싱글 바이트 캐릭터 셋**과 이에 상응하는 **와이드 스트링 함수**는 문자열 조작에 필수적인 함수들이다.
- **SBCS 기반 함수**는 아스키 문자열 처리에 적합하며, 유니코드 문자열 처리에는 정확한 결과를 보장하지 않는다.
- 유니코드와 아스키 코드 기반을 섞어 사용하는 것은 비효율적이며, 통일성이 결여되어 문제가 생길 수 있다.
- 문자열을 **유니코드**로 선언하려면 반드시 `L` 키워드가 필요하며, 없을 경우 아스키 코드 기반으로 처리된다.
- **와이드 바이트 캐릭터셋 함수**는 함수 이름 앞에 `w`를 붙이는 방식으로 활용 가능하고, 이는 기억하기 편리하다.

# 5. 🖨️ 유니코드 기반 문자열 처리

## 예제 2-5] WBCS2.cpp 유니코드 버전

> 💬 **매개변수 선언은 어떻게?**

```c
int main(void)
{
    wchar_t str[] = L"ABC";
    int size = sizeof(str);
    int len = wcslen(str);

    wprintf(L"Array Size : %d \n", size);
    wprintf(L"String Length : %d \n", len);

    return 0;
}

- 실행 파일이 "테스트.exe"일 경우, 문자열 인자는 배열 형태로 전달된다.
- 문자열 구성을 유니코드 기반으로 변경, 앞에 L을 붙여야 한다.
- 전달 받는 인자의 타입도 변경해야 하고, 캐릭터 타입 대신 와이드 캐릭터 타입을 사용해야 한다.
```
